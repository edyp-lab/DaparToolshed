% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregation.R
\name{inner.aggregate.iter}
\alias{inner.aggregate.iter}
\title{Aggregation of quantitative data with redistribution of shared peptides}
\usage{
inner.aggregate.iter(
  pepData,
  X,
  init.method = "Mean",
  method = "Mean",
  n = NULL,
  uniqueiter = FALSE,
  topn_fun = "Mean",
  max_iter = 500
)
}
\arguments{
\item{pepData}{A \code{matrix} containing the peptide intensities.}

\item{X}{A \code{matrix} acting as an adjacency matrix.}

\item{init.method}{A function used for initializing the aggregation.
Available functions are \code{Sum}, \code{Mean}, \code{Median}, \code{medianPolish} or \code{robustSummary}.
See below for details.}

\item{method}{A function used for the aggregation.
Available functions are \code{Sum}, \code{Mean}, \code{Median}, \code{medianPolish} or \code{robustSummary}.
See below for details.}

\item{n}{A \code{numeric(1)} specifying the number of peptides to use for each protein. If \code{NULL}, all peptides are considered.}

\item{uniqueiter}{A bole}

\item{topn_fun}{A function used to determine how to choose the top n peptides.
Available functions are \code{Sum}, \code{Mean} or \code{Median}.
See below for details.}

\item{max_iter}{A \code{numeric(1)} setting the maximum number of iteration.}
}
\value{
A \code{matrix} containing the aggregated values.
}
\description{
This function aggregate quantitative data using a method of redistribution of shared peptides. Intensity of shared peptides are redistributed proportionally to each protein.
Note that the function assumes that the intensities are not log-transformed.
}
\details{
Available functions are :
\itemize{
\item \code{Sum} : \code{\link[base:colSums]{base::rowSums()}}
\item \code{Mean} : \code{\link[base:colSums]{base::rowMeans()}}
\item \code{Median} : \code{\link[matrixStats:rowMedians]{matrixStats::rowMedians()}}
\item \code{medianPolish} : \code{\link[MsCoreUtils:medianPolish]{MsCoreUtils::medianPolish()}}, not available for \code{topn_fun}.
Note that this method takes significantly more time than the others, and is parallelized to be more efficient.
\item \code{robustSummary} : \code{\link[MsCoreUtils:robustSummary]{MsCoreUtils::robustSummary()}}, not available for \code{topn_fun}.
Note that this method takes significantly more time than the others, and is parallelized to be more efficient.
}
}
\examples{
\dontrun{
data(Exp1_R25_pept, package="DaparToolshedData")
obj <- Exp1_R25_pept[seq_len(10)]
X <- BuildAdjacencyMatrix(obj[[length(obj)]])
qdata.agg <- inner.aggregate.iter(assay(obj[[length(obj)]]), X)
}

}
\author{
Samuel Wieczorek, Manon Gaudin
}
