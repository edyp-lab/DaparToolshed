% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregation.R
\name{DaparToolshed-aggregateRedistribution}
\alias{DaparToolshed-aggregateRedistribution}
\alias{aggregateRedistribution}
\alias{aggregateRedistribution,QFeatures-method}
\alias{aggregateRedistribution,SummarizedExperiment-method}
\title{Aggregate an assay's quantitative features with shared peptide redistribution}
\usage{
aggregateRedistribution(object, ...)

\S4method{aggregateRedistribution}{QFeatures}(
  object,
  i,
  name = "newAssay",
  fcol,
  init.method = "Mean",
  method = "Mean",
  ponderation = "Global",
  n = NULL,
  uniqueiter = FALSE,
  max_iter = 500
)

\S4method{aggregateRedistribution}{SummarizedExperiment}(
  object,
  fcol,
  init.method = "Mean",
  method = "Mean",
  ponderation = "Global",
  n = NULL,
  uniqueiter = FALSE,
  conds,
  max_iter = 500
)
}
\arguments{
\item{object}{An instance of class \code{QFeatures} or \code{SummarizedExperiment}}

\item{...}{Additional parameters.}

\item{i}{The index or name of the assay which features will be aggregated the create the new assay.}

\item{name}{A \code{character(1)} naming the new assay. Default is \code{newAssay}.
Note that the function will fail if there's already an assay with \code{name}.}

\item{fcol}{A \code{character(1)} naming a rowdata variable (of assay \code{i} in case of a \code{QFeatures})
defining how to aggregate the features of the assay.
This variable is a (possibly sparse) matrix. See below for details.}

\item{init.method}{A function used for initializing the aggregation.
Available functions are \code{Sum}, \code{Mean}, \code{Median}, \code{medianPolish} or \code{robustSummary}.
See \code{DaparToolshed::inner.aggregate.iter()} for details.}

\item{method}{A function used for the aggregation.
Available functions are \code{Sum}, \code{Mean}, \code{Median} or \code{medianPolish}.
See \code{DaparToolshed::inner.aggregate.iter()} for details.}

\item{ponderation}{A \code{character(1)} defining what to consider to create the coefficient for redistribution of shared peptides.
Available values are \code{Global} (default), \code{Condition} or \code{Sample}.}

\item{n}{A \code{numeric(1)} specifying the number of peptides to use for each protein. If \code{NULL}, all peptides are considered.}

\item{uniqueiter}{A \code{boolean} indication if there should be only 1 iteration or not.}

\item{max_iter}{A \code{numeric(1)} setting the maximum number of iteration.}

\item{conds}{A \code{character()} vector which is the names of conditions.}
}
\value{
A \code{QFeatures} object with an additional assay or a \code{SummarizedExperiment} object (or subclass thereof).
}
\description{
This function aggregates the quantitative features of an assay,
applying a summarization function (\code{fun}) to sets of features.
The \code{fcol} variable name points to a rowData column that defines
how to group the features during aggregate. This variable has to
be an adjacency matrix. This function uses \code{DaparToolshed::inner.aggregate.iter()}
to aggregate quantitative data.

The list of agregation methods can be obtained with the function
\code{aggregateMethods()}. This function compiles both methods from the
packages \code{DaparToolshed} and \code{QFeatures}.
}
\details{
This function uses \code{DaparToolshed::inner.aggregate.iter()} to aggregate quantitative data.
}
\section{Iterative aggregation function}{

xxxxxx
xxxxx
}

\section{Quantitative metadata aggregation}{

The function to aggregate the quantitative metadata is \code{aggQmetadat()}
}

\examples{

## ---------------------------------------
## An example QFeatures with PSM-level data
## ---------------------------------------
\donttest{
data(subR25prot)
library(SummarizedExperiment)
subR25prot

## Aggregate peptides into proteins
## using the adjacency matrix
feat1 <- aggregateRedistribution(object = subR25prot,
i = 1,
name = 'aggregated',
fcol = 'adjacencyMatrix',
init.method = 'Mean',
method = 'Mean')
feat1

assay(feat1[[1]])
assay(feat1[[2]])
aggcounts(feat1[[2]])
assay(feat1[[3]])
aggcounts(feat1[[3]])
rowData(feat1[[2]])
}
}
\seealso{
The \emph{QFeatures} vignette provides an extended example and the \emph{Aggregation} vignette,
for a complete quantitative proteomics data processing pipeline.
}
