% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregation_func.R
\name{aggregateQmetadata}
\alias{aggregateQmetadata}
\alias{aggregateFeatures}
\alias{aggregateFeatures,QFeatures-method}
\alias{aggcounts}
\alias{aggcounts,SummarizedExperiment-method}
\alias{adjacencyMatrix,SummarizedExperiment-method}
\alias{adjacencyMatrix,QFeatures-method}
\alias{inner.aggregate.iter}
\alias{aggIterParallel}
\alias{aggIterative}
\alias{rowdata_stats_Aggregation_sam}
\alias{aggQmeta}
\alias{FinalizeAggregation,QFeatures-method}
\title{Aggregate an assay's quantitative features}
\usage{
inner.aggregate.iter(
  qData,
  X,
  init.method = "colSumsMat",
  iter.method = "Mean",
  n = NULL
)

aggIterParallel(
  qPepData,
  X,
  conditions = NULL,
  init.method = "Sum",
  method = "Mean",
  n = NULL
)

aggIterative(
  x,
  MAT,
  conditions = NULL,
  init.method = "Sum",
  iter.method = "Mean",
  n = NULL
)

rowdata_stats_Aggregation_sam(qPepData, X)

aggQmeta(object, conds)

\S4method{FinalizeAggregation}{QFeatures}(object, from, to, ...)
}
\arguments{
\item{X}{An adjacency matrix in which lines and columns correspond 
respectively to peptides and proteins.}

\item{init.method}{The method used to initialize the iterative algotirhm. Default is 'Sum'.}

\item{n}{xxxx}

\item{qPepData}{A data.frame of quantitative data not logged of peptides}

\item{conditions}{xxx}

\item{method}{The method used for xxx. Default value is 'Mean'.}

\item{object}{An object of class 'SummarizedExperiment'}

\item{conds}{xxx}

\item{...}{Additional parameters passed the `fun`.}

\item{i}{The index or name of the assay which features will be
aggregated the create the new assay.}

\item{fcol}{A `character(1)` naming a rowdata variable (of assay
`i` in case of a `QFeatures`) defining how to aggregate the
features of the assay. This variable is either a `character`
or a (possibly sparse) matrix. See below for details.}

\item{name}{A `character(1)` naming the new assay. Default is
`newAssay`. Note that the function will fail if there's
already an assay with `name`.}

\item{fun}{A function used for quantitative feature
aggregation. See Details for examples.}

\item{obj.pep}{A peptide object of class \code{MSnset}}

\item{pepData}{xxxx}

\item{protData}{xxxxx}

\item{protMetacell}{xxx}
}
\value{
A `QFeatures` object with an additional assay or a
 `SummarizedExperiment` object (or subclass thereof).

A  matrix containing the quantitative aggregated data for proteins.

A matrix of intensities of proteins

A matrix of protein intensities.

A protein object of class \code{SummarizedExperiment}

NA

A protein object of class \code{MSnset}
}
\description{
This function aggregates the quantitative features of an assay,
applying a summarisation function (`fun`) to sets of features.
The `fcol` variable name points to a rowData column that defines
how to group the features during aggregate. This variable can
eigher be a vector (we then refer to an *aggregation by vector*)
or an adjacency matrix (*aggregation by matrix*).

Method to aggregate peptides into proteins with the iterative approach.

Method to aggregate peptides into proteins with the iterative approach with use of parallelism.

Method to aggregate peptides into proteins with the iterative approach
}
\examples{

library(QFeatures)
Exp1_R25_pept <- readRDS(system.file("data", 'Exp1_R25_pept.rda', package="DaparToolshedData"))
obj <- Exp1_R25_pept[seq_len(1000),]
obj <- addListAdjacencyMatrices(obj, 2)
X <- GetAdjMat(obj[[2]])$all
qPepData <- assay(obj[[2]])
inner.aggregate.iter(qPepData, X)

library(doParallel)
library(QFeatures)
Exp1_R25_pept <- readRDS(system.file("data", 'Exp1_R25_pept.rda', package="DaparToolshedData"))
obj <- Exp1_R25_pept[seq_len(1000),]
obj <- addListAdjacencyMatrices(obj, 2)
X <- as.matrix(GetAdjMat(obj[[2]])$all)
conditions <- SummarizedExperiment::colData(obj)$Condition
aggIterParallel(assay(obj,2), X, conditions)

library(QFeatures)
Exp1_R25_pept <- readRDS(system.file("data", 'Exp1_R25_pept.rda', package="DaparToolshedData"))
obj <- Exp1_R25_pept[seq_len(1000),]
obj <- addListAdjacencyMatrices(obj, 2)
X <- as.matrix(GetAdjMat(obj[[2]])$all)
conditions <- colData(obj)$Condition
aggIter(assay(obj,2), X, conditions)

library(QFeatures)
Exp1_R25_pept <- readRDS(system.file("data", 'Exp1_R25_pept.rda', package="DaparToolshedData"))
obj <- Exp1_R25_pept[seq_len(1000),]
obj <- addListAdjacencyMatrices(obj, 2)
X <- GetAdjMat(obj[[2]])$all
rowdata_stats_Aggregation_sam(assay(obj,2), X)

Exp1_R25_pept <- readRDS(system.file("data", 'Exp1_R25_pept.rda', package="DaparToolshedData"))
obj <- Exp1_R25_pept[1:100]
FinalizeAggregation(obj, 2)

}
\seealso{
The *QFeatures* vignette provides an extended example and
    the *Processing* vignette, for a complete quantitative
    proteomics data processing pipeline. The
    [MsCoreUtils::aggregate_by_vector()] manual page provides
    further details.
}
\author{
Samuel Wieczorek, Thomas Burger

Samuel Wieczorek

Samuel Wieczorek

Samuel Wieczorek

Samuel Wieczorek
}
