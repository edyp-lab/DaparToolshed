% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregation.R
\name{RunAggregation}
\alias{RunAggregation}
\title{Aggregation of peptide-level assay QFeatures}
\usage{
RunAggregation(
  qf,
  includeSharedPeptides = "Yes_As_Specific",
  operator = "Mean",
  considerPeptides = "allPeptides",
  adjMatrix = "adjacencyMatrix",
  ponderation = "Global",
  n = NULL,
  aggregated_col = NULL,
  max_iter = 500
)
}
\arguments{
\item{qf}{An instance of class \link[QFeatures:QFeatures-class]{QFeatures::QFeatures}. The last assay contained in \code{qf} will be aggregated. Intensities are assumed to already be log-transformed.}

\item{includeSharedPeptides}{How shared peptides are handled. Either \code{Yes_As_Specific} (default), \code{Yes_Iterative_Redistribution}, \code{Yes_Simple_Redistribution} or \code{No}.
See below for details.}

\item{operator}{A function used for quantitative feature aggregation.
Available functions are \code{Sum}, \code{Mean}, \code{Median}, \code{medianPolish} or \code{robustSummary}.
See below for details.}

\item{considerPeptides}{A \code{character(1)} defining what peptide to consider. Available values are \code{allPeptides} (default) and \code{topN}.}

\item{adjMatrix}{A \code{character(1)} naming a rowdata variable from the last assay of \code{qf} containing an adjacency matrix.}

\item{ponderation}{A \code{character(1)} defining what to consider to create the coefficient for redistribution of shared peptides.
Available values are \code{Global} (default), \code{Condition} or \code{Sample}.}

\item{n}{If \code{topN}, specify the number of peptides to use for each protein.}

\item{aggregated_col}{A \code{character()} of column names from rowdata to be aggregated.}

\item{max_iter}{A \code{numeric(1)} setting the maximum number of iteration.}
}
\value{
A \link[QFeatures:QFeatures-class]{QFeatures::QFeatures} with an aggregated assay added.
}
\description{
This function aggregate both quantitative and rowdata from the last assay contained in a \code{QFeatures}.
Note that the function assumes that the intensities in the QFeatures are already log-transformed.
}
\details{
Aggregation of quantitative data is performed using \link[ProtGenerics:protgenerics]{ProtGenerics::aggregateFeatures}, or \link{inner.aggregate.iter} if \code{Yes_Iterative_Redistribution} or \code{Yes_Simple_Redistribution} is selected.

The handling of shared peptide is as follow :
\itemize{
\item \code{Yes_As_Specific} : Shared peptides are used multiple times.
Each peptide is duplicated as many times as the number of proteins in which they are present, and thus are considered as if they are specific to each protein.
\item \code{Yes_Simple_Redistribution} : Intensity of shared peptides are redistributed proportionally to each protein. See \link{inner.aggregate.iter} for more information.
\item \code{Yes_Iterative_Redistribution} : Intensity of shared peptides are redistributed proportionally to each protein. See \link{inner.aggregate.iter} for more information.
\item \code{No} : No shared peptides are used. If a peptide contained only shared peptides, its intensity is set as 0 for every sample.
}

Available functions are :
\itemize{
\item \code{Sum} : \code{\link[base:colSums]{base::colSums()}} or \code{\link[base:colSums]{base::rowSums()}} if \code{Yes_Iterative_Redistribution} or \code{Yes_Simple_Redistribution}.
\item \code{Mean} : \code{\link[base:colSums]{base::colMeans()}} or \code{\link[base:colSums]{base::rowMeans()}} if \code{Yes_Iterative_Redistribution} or \code{Yes_Simple_Redistribution}.
\item \code{Median} : \code{\link[matrixStats:rowMedians]{matrixStats::colMedians()}} or \code{\link[matrixStats:rowMedians]{matrixStats::rowMedians()}} if \code{Yes_Iterative_Redistribution} or \code{Yes_Simple_Redistribution}.
\item \code{medianPolish} : \code{\link[MsCoreUtils:medianPolish]{MsCoreUtils::medianPolish()}}.
\item \code{robustSummary} : \code{\link[MsCoreUtils:robustSummary]{MsCoreUtils::robustSummary()}}.
}
}
\examples{
\dontrun{
data(Exp1_R25_pept, package="DaparToolshedData")
ft <- Exp1_R25_pept[1:100]
obj.agg <- RunAggregation(ft, "Yes_As_Specific", "Sum", "allPeptides", aggregated_col = colnames(SummarizedExperiment::rowData(ft[[length(ft)]])))
obj.agg <- RunAggregation(ft, "Yes_As_Specific", "Mean", "allPeptides", aggregated_col = colnames(SummarizedExperiment::rowData(ft[[length(ft)]])))
obj.agg <- RunAggregation(ft, "Yes_As_Specific", "Sum", "topN", n = 4, aggregated_col = colnames(SummarizedExperiment::rowData(ft[[length(ft)]])))
obj.agg <- RunAggregation(ft, "Yes_As_Specific", "Mean", "topN", n = 4, aggregated_col = colnames(SummarizedExperiment::rowData(ft[[length(ft)]])))

obj.agg <- RunAggregation(ft, "No", "Sum", "allPeptides")
obj.agg <- RunAggregation(ft, "No", "Sum", "topN", n = 4)

obj.agg <- RunAggregation(ft, "Yes_Redistribution", "Sum", "allPeptides", aggregated_col = colnames(SummarizedExperiment::rowData(ft[[length(ft)]])))
obj.agg <- RunAggregation(ft, "Yes_Redistribution", "Sum", "topN", n = 4, aggregated_col = colnames(SummarizedExperiment::rowData(ft[[length(ft)]])))
}

}
\author{
Samuel Wieczorek, Manon Gaudin
}
