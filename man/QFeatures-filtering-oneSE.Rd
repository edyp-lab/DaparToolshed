% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DaparToolshed-filterFeaturesOneSE.R
\docType{class}
\name{QFeatures-filtering-oneSE}
\alias{QFeatures-filtering-oneSE}
\alias{filterFeaturesOneSE}
\alias{filterFeaturesOneSE,}
\alias{DaparToolsehd,}
\alias{FunctionFilter,}
\alias{VariableFilter}
\alias{FunctionFilter-class}
\alias{FunctionFilter}
\alias{filterFeaturesOneSE,QFeatures-method}
\alias{filterFeaturesOneSE,SummarizedExperiment-method}
\title{Filter features of one SE based on their rowData}
\usage{
FunctionFilter(name, ...)

\S4method{filterFeaturesOneSE}{QFeatures}(object, i, name = "newAssay", filters)

\S4method{filterFeaturesOneSE}{SummarizedExperiment}(object, filters)
}
\arguments{
\item{name}{A `character(1)` naming the new assay. Default is
`newAssay`. Note that the function will fail if there's
already an assay with `name`.}

\item{object}{An instance of class [QFeatures] or [SummarizedExperiment].}

\item{i}{The index or name of the assay which features will be
filtered the create the new assay.}

\item{filters}{A `list()` containing instances of class [AnnotationFilter] or 
[FunctionFilter]}

\item{params}{`character()` or `integer()` parameters for the
`name` function.}
}
\value{
A filtered `QFeature` object
}
\description{
The `filterFeaturesOneSE` methods enables users to filter features
based on a variable in their `rowData`. It is directly inspired of the
function `filterFeature` of the package `QFeatures`. 
The first difference is that the filter only applies to one `SummarizedExperiment`
contained in the object rather than applying on all the SE.
This method generates a new `SummarizedExperiment` object which is added to the `QFeatures` object.
If the SE on which the filter applies is the last one of the object, then a new xxxx.
If it is not the last one, the new SE is added and all the further SE are deleted.
The features matching the
The filters can be provided as instances of class `AnnotationFilter` (see the package `QFeatures`)
or of class `FunctionFilter` (see below).
}
\section{Function filters}{


The function filters are filters as defined in the
[DaparToolshed] package. Each filter is defined by a name (which is the name of a function)
and a list which contains the parameters passed to the function.
Those filters can be created with the `FunctionFilter` constructor.

Those functions are divided into two main categories:
 - the one that filter on one rowData feature,
 - the one based on a two-dimensional information such as the adjacency matrix
 
 for the first category, all filters of class [AnnotationFilter] can be used as they
 are used in `QFeatures`
 
 For the second category, the package `DaparToolshed` provides filter functions based either 
 on the adjacency matrix:
 - [DaparToolshed::topnPeptides()]: xxxx
 - [DaparToolshed::sharedPeptides()]: xxx
 - [DaparToolshed::specPeptides()]: xxx
 
Or based on the quantitative metadata (identification):
 - [DaparToolshed::qMetadatWholeMatrix()]: xxx
 - [DaparToolshed::qMetadataWholeLine()]: xxx
 - [DaparToolshed::qMetadataOnConditions()]: xxx
}

\examples{

## ----------------------------------------
## Creating function filters
## ----------------------------------------

FunctionFilter('FUN', 
               param1 = 'value_of_param1', 
               param2 = 'value_of_param2')
               
FunctionFilter('qMetadataWholeLine', 
               cmd = 'delete', 
               pattern = 'imputed POV')
               
## ----------------------------------------------------------------
## Filter the last assay to keep only specific peptides. This filter 
## only applies on peptide dataset.
## ----------------------------------------------------------------

spec.filter <- FunctionFilter('specPeptides', list())
## using a user-defined character filter
filterFeaturesOneSE(feat1, list(FunctionFilter('specPeptides', list())))


## ----------------------------------------------------------------
## Filter the last assay to keep only specific peptides and topn peptides. The
## two filters are run sequentially.
## ----------------------------------------------------------------

lst.filters <- list(FunctionFilter('specPeptides', list()))
lst.filters <- append(lst.filters, 
                      FunctionFilter('topnPeptides', 
                      fun = 'rowSums', 
                      top = 2))
filterFeaturesOneSE(feat1, lst.filters)

## ----------------------------------------------------------------
## Filter the last assay to delete peptides where, in at least one condition,
## there is less than 80\% of samples marked as 'imputed POV'
## ----------------------------------------------------------------

filter <- FunctionFilter('qMetadataOnConditions', 
                        cmd = 'delete',
                        mode = 'AtLeastOneCond',
                        pattern = 'imputed POV',
                        conds = colData(ft)$Condition,
                        percent = TRUE, 
                        th = 0.8, 
                        operator = '<')
                        
 filterFeaturesOneSE(feat1, filter)  
 
                       
}
\author{
Samuel Wieczorek
}
